@top Request { Query }

@skip { space | Comment }

Query { "query" argsOpening RootConstraint (argsDelimiter RootConstraint)* argsClosing }

QueryBody { argsOpening RootConstraint (argsDelimiter RootConstraint)* argsClosing }

/* temporary separation of constraint types before we have full LSP completion/linter */
RootConstraint { ("collection" | "filterBy" | "orderBy" | "require") ConstraintBody }

Constraint { constraintName ConstraintBody }

ConstraintBody { argsOpening (arg (argsDelimiter arg)*)? argsClosing }

arg {
    valueToken |
    Constraint
}

valueToken {
    String |
    Int |
    Float |
    Boolean |
    Date |
    Time |
    DateTime |
    OffsetDateTime |
    Range {
        emptyRange { "[" "," "]" ~range } |
        dateTimeRange { "[" OffsetDateTime? "," OffsetDateTime? "]" ~range } |
        floatNumberRange { "[" Float? "," Float? "]" ~range } |
        intNumberRange { "[" Int? "," Int? "]" ~range }
    } |
    Uuid |
    Enum
}

@tokens {
    /* temporary list of supported constraint before we have full LSP completion/linter */
    constraintName {
        "filterGroupBy" |
        "and" |
        "or" |
        "not" |
        "userFilter" |
        "attributeEquals" |
        "attributeGreaterThan" |
        "attributeGreaterThanEquals" |
        "attributeLessThan" |
        "attributeLessThanEquals" |
        "attributeBetween" |
        "attributeInSet" |
        "attributeContains" |
        "attributeStartsWith" |
        "attributeEndsWith" |
        "attributeEqualsTrue" |
        "attributeEqualsFalse" |
        "attributeIs" |
        "attributeIsNull" |
        "attributeIsNotNull" |
        "attributeInRange" |
        "attributeInRangeNow" |
        "entityPrimaryKeyInSet" |
        "entityLocaleEquals" |
        "priceInCurrency" |
        "priceInPriceLists" |
        "priceValidInNow" |
        "priceValidIn" |
        "priceBetween" |
        "facetHaving" |
        "referenceHaving" |
        "hierarchyWithin" |
        "hierarchyWithinSelf" |
        "hierarchyWithinRoot" |
        "hierarchyWithinRootSelf" |
        "directRelation" |
        "having" |
        "excludingRoot" |
        "excluding" |
        "entityHaving" |
        "orderGroupBy" |
        "attributeNatural" |
        "attributeSetExact" |
        "attributeSetInFilter" |
        "priceNatural" |
        "random" |
        "referenceProperty" |
        "entityPrimaryKeyNatural" |
        "entityPrimaryKeyExact" |
        "entityPrimaryKeyInFilter" |
        "entityProperty" |
        "entityGroupProperty" |
        "page" |
        "strip" |
        "entityFetch" |
        "entityGroupFetch" |
        "attributeContent" |
        "attributeContentAll" |
        "priceContent" |
        "priceContentAll" |
        "priceContentRespectingFilter" |
        "associatedDataContent" |
        "associatedDataContentAll" |
        "referenceContentAll" |
        "referenceContent" |
        "referenceContentAllWithAttributes" |
        "referenceContentWithAttributes" |
        "hierarchyContent" |
        "priceType" |
        "dataInLocalesAll" |
        "dataInLocales" |
        "facetSummary" |
        "facetSummaryOfReference" |
        "facetGroupsConjunction" |
        "facetGroupsDisjunction" |
        "facetGroupsNegation" |
        "attributeHistogram" |
        "priceHistogram" |
        "distance" |
        "level" |
        "node" |
        "stopAt" |
        "statistics" |
        "fromRoot" |
        "children" |
        "siblings" |
        "parents" |
        "hierarchyOfSelf" |
        "hierarchyOfReference" |
        "queryTelemetry"
    }

    String {
        ('"' (!["\\] | "\\" _)* '"') |
        ('\'' (!["\\] | "\\" _)* '\'')
    }

    Int { "-"? @digit+ }

    Float { "-"? @digit+ "." @digit+ }

    Boolean { "true" | "false" }

    Date { @digit @digit @digit @digit "-" @digit @digit "-" @digit @digit }

    Time { @digit @digit ":" @digit @digit ":" @digit @digit ("." @digit+)? }

    DateTime { Date "T" Time }

    OffsetDateTime { DateTime ("+" | "-") @digit @digit ":" @digit @digit }

    Uuid { $[a-z0-9]+ "-" $[a-z0-9]+ "-" $[a-z0-9]+ "-" $[a-z0-9]+ "-" $[a-z0-9]+ }

    Enum { @asciiUppercase+ ("_" @asciiUppercase+)* }

    argsOpening { "(" }

    argsClosing { ")" }

    argsDelimiter { "," }

    Comment { "//" ![\n]* }

    space { $[ \t\n\r]+ }

    @precedence {
        constraintName,
        String,
        OffsetDateTime,
        DateTime,
        Date,
        Time,
        Float,
        Int,
        Boolean,
        Uuid,
        Enum
    }
}

@detectDelim